import { format } from 'date-fns';
import { Expense } from '@/types';

export interface ExportOptions {
  format: 'csv' | 'json' | 'pdf';
  filename: string;
}

// CSV Export
export function exportToCSV(expenses: Expense[]): string {
  const headers = ['Date', 'Category', 'Amount', 'Description'];
  const csvContent = [
    headers.join(','),
    ...expenses.map((expense) =>
      [
        expense.date,
        expense.category,
        expense.amount,
        `"${expense.description.replace(/"/g, '""')}"`,
      ].join(',')
    ),
  ].join('\n');

  return csvContent;
}

// JSON Export
export function exportToJSON(expenses: Expense[]): string {
  const exportData = {
    exportDate: new Date().toISOString(),
    totalExpenses: expenses.length,
    totalAmount: expenses.reduce((sum, expense) => sum + expense.amount, 0),
    expenses: expenses.map(expense => ({
      id: expense.id,
      date: expense.date,
      category: expense.category,
      amount: expense.amount,
      description: expense.description,
      createdAt: expense.createdAt,
      updatedAt: expense.updatedAt
    }))
  };

  return JSON.stringify(exportData, null, 2);
}

// PDF Export (simplified HTML-based approach)
export function exportToPDF(expenses: Expense[]): string {
  const totalAmount = expenses.reduce((sum, expense) => sum + expense.amount, 0);
  const exportDate = format(new Date(), 'MMMM dd, yyyy');

  const htmlContent = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Expense Report</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 40px;
            color: #333;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #eee;
            padding-bottom: 20px;
        }
        .summary {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        .summary-item {
            display: inline-block;
            margin-right: 40px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .amount {
            text-align: right;
            font-weight: bold;
        }
        .category {
            background: #e3f2fd;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        .footer {
            margin-top: 30px;
            text-align: center;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Expense Report</h1>
        <p>Generated on ${exportDate}</p>
    </div>
    
    <div class="summary">
        <div class="summary-item">
            <strong>Total Expenses:</strong> ${expenses.length}
        </div>
        <div class="summary-item">
            <strong>Total Amount:</strong> $${totalAmount.toFixed(2)}
        </div>
        <div class="summary-item">
            <strong>Date Range:</strong> ${expenses.length > 0 
              ? `${format(new Date(Math.min(...expenses.map(e => new Date(e.date).getTime()))), 'MMM dd, yyyy')} - ${format(new Date(Math.max(...expenses.map(e => new Date(e.date).getTime()))), 'MMM dd, yyyy')}`
              : 'No expenses'
            }
        </div>
    </div>

    <table>
        <thead>
            <tr>
                <th>Date</th>
                <th>Category</th>
                <th>Description</th>
                <th>Amount</th>
            </tr>
        </thead>
        <tbody>
            ${expenses.map(expense => `
                <tr>
                    <td>${format(new Date(expense.date), 'MMM dd, yyyy')}</td>
                    <td><span class="category">${expense.category}</span></td>
                    <td>${expense.description}</td>
                    <td class="amount">$${expense.amount.toFixed(2)}</td>
                </tr>
            `).join('')}
        </tbody>
    </table>

    <div class="footer">
        <p>This report was generated by ExpenseTracker AI</p>
    </div>
</body>
</html>`;

  return htmlContent;
}

// File Download Utilities
export function downloadFile(content: string, filename: string, mimeType: string): void {
  const blob = new Blob([content], { type: mimeType });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// PDF Download (using print functionality)
export function downloadPDF(htmlContent: string): void {
  const printWindow = window.open('', '_blank');
  if (printWindow) {
    printWindow.document.write(htmlContent);
    printWindow.document.close();
    
    // Wait for content to load, then trigger print
    printWindow.onload = () => {
      setTimeout(() => {
        printWindow.print();
        printWindow.close();
      }, 250);
    };
  }
}

// Main Export Function
export async function exportExpenses(
  expenses: Expense[], 
  options: ExportOptions
): Promise<void> {
  const { format, filename } = options;
  
  // Add a small delay to simulate processing
  await new Promise(resolve => setTimeout(resolve, 500));

  switch (format) {
    case 'csv':
      const csvContent = exportToCSV(expenses);
      downloadFile(csvContent, `${filename}.csv`, 'text/csv;charset=utf-8;');
      break;
      
    case 'json':
      const jsonContent = exportToJSON(expenses);
      downloadFile(jsonContent, `${filename}.json`, 'application/json;charset=utf-8;');
      break;
      
    case 'pdf':
      const pdfContent = exportToPDF(expenses);
      downloadPDF(pdfContent);
      break;
      
    default:
      throw new Error(`Unsupported export format: ${format}`);
  }
}